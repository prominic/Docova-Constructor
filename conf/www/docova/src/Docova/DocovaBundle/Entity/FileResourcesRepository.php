<?php
namespace Docova\DocovaBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

/**
 * FileResourcesRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class FileResourcesRepository extends EntityRepository
{
	public function getFileResourcePath($rootPath,$name)
	{
		if (empty($name) || $name=="")
		{
			return null;
		}
	
		$file_info = $this->findOneBy(array('Name'=>$name));
		if (empty($file_info))
		{
			
			throw new NotFoundHttpException('Unspecified source File Resource with ID = '. $name);
		}
	
		$file_path_header = $this->generatePathHeader($rootPath,$file_info, true,"Resources");
	
		if (empty($file_path_header)) {
			throw new NotFoundHttpException('Could not download or find the selected file.');
		}
	
		return $file_path_header['file_path'];
	}
	
	public function getFileResourceContent($rootPath,$resource_name){
		$filePath = $this->getFileResourcePath($rootPath, $resource_name);
		return \file_get_contents($filePath);
	}
	public function getFileResources()
	{
		$file_resources = $this->findAll();
		if (empty($file_resources))		
			return array("None Available");		
		else{
			$fileResources = array();
			foreach($file_resources as $file_resource){
				$fileResources[] = $file_resource->getName();
			}
			return $fileResources;
		}
	}
	/**
	 * find mime type of a file
	 * @param : file name
	 * @return: string representing the mime type
	 */
	 
	public function GetMimeTypeEx($fname) {
	
		ob_start();
		system("file -i -b {$fname}");
		$output = ob_get_clean();
		$output = explode("; ",$output);
		if ( is_array($output) ) {
			$output = $output[0];
		}
		return $output;
	}
	
	/**
	 * Generate file path and required header options for response.
	 * If file does not exist returns false
	 *
	 * @param object $record_obj
	 * @return array
	 */
	private function generatePathHeader($rootPath,$record_obj, $is_template = false, $type)
	{
		$UPLOAD_FILE_PATH = $rootPath ? $rootPath.DIRECTORY_SEPARATOR.'Docova'.DIRECTORY_SEPARATOR.'_storage' : $_SERVER['DOCUMENT_ROOT'].DIRECTORY_SEPARATOR.'Docova'.DIRECTORY_SEPARATOR.'_storage';
		
		$file_name		= $record_obj->getFileName();
	
		if (!file_exists($UPLOAD_FILE_PATH.DIRECTORY_SEPARATOR.$type.DIRECTORY_SEPARATOR.md5($file_name))) {
			return false;
		}
	
		$file_path = $UPLOAD_FILE_PATH.DIRECTORY_SEPARATOR.$type.DIRECTORY_SEPARATOR.md5($file_name);
	
		$mtype = $this->GetMimeTypeEx($file_path );
		$mtype = !empty($mtype) ? $mtype : $record_obj->getFileMimeType();
	
		if ($is_template === true) {
			$headers = array(
					//'Content-Type' => $record_obj->getFileMimeType(),
					'Content-Type' => $mtype,
					'Content-Disposition' => 'inline; filename="'.$record_obj->getFileName().'"',
			);
		}
	
		return array(
				'file_path' => $file_path,
				'headers' => $headers
		);
	}
	public function getDataXML($criteria = array(), $sortBy = array(), $return_obj = false)
	{
		if (empty($criteria) && empty($sortBy)) {
			$templates = $this->findAll();
		}
		else {
			$orderBy = array();
			if (!empty($sortBy))
			{
				foreach ($sortBy as $key => $value) {
					if ($this->_class->hasField($key)) {
						$orderBy[$key] = strtoupper($value) == 'DESC' ? 'DESC' : 'ASC';
					}
					else {
						if ($key == 'Type' && !empty($value)) {
							$orderBy['Type'] = strtoupper($value) == 'DESC' ? 'DESC' : 'ASC';
						}
						elseif ($key == 'Name' && !empty($value)) {
							$orderBy['File_Name'] = strtoupper($value) == 'DESC' ? 'DESC' : 'ASC';
						}
					}
				}
			}
			$templates = $this->findBy($criteria, $orderBy);
		}
		
		$data_xml = ($return_obj === false) ? array() : new \DOMDocument('1.0', 'UTF-8');
		foreach ($templates as $doc)
		{
			if ($return_obj === false)
			{
				$data_xml[] = array(
						'dockey' => $doc->getId(),
						'type' => $doc->getType(),
						'name' => $doc->getName()						
				);
		/*		
				$data_xml .= '<document>';
				$data_xml .= '<dockey>'.$doc->getId().'</dockey>';
				$data_xml .= '<docid>'.$doc->getId().'</docid>';
				$data_xml .= '<rectype>doc</rectype>';
				$data_xml .= '<type><![CDATA['.$doc->getType().']]></type>';
				$data_xml .= '<name><![CDATA['.$doc->getName().']]></name>';
				$data_xml .= '<statno />';
				$data_xml .= '<wfstarted />';
				$data_xml .= '<delflag />';
				$data_xml .= '</document>';
		*/
			}
			else {
				$root = $data_xml->appendChild($data_xml->createElement('document'));
				$root->appendChild($data_xml->createElement('dockey', $doc->getId()));
				$root->appendChild($data_xml->createElement('docid', $doc->getId()));
				$root->appendChild($data_xml->createElement('rectype', 'doc'));
				$cdata = $data_xml->createCDATASection($doc->getType());
				$newnode = $data_xml->createElement('type');
				$newnode->appendChild($cdata);
				$root->appendChild($newnode);
				$cdata = $data_xml->createCDATASection($doc->getName);
				$newnode = $data_xml->createElement('name');
				$newnode->appendChild($cdata);
				$root->appendChild($newnode);
			}
		}
		
		return $data_xml;
	}
	
	/*
	 * Deletes documents from web admin view
	* @param: xml data with id to delete
	* @return: xml Data response
	*/
	public function deleteSelectedDocuments($post_xml){
	
		$deleted=0;
	
		foreach ($post_xml->getElementsByTagName('Unid') as $doc_id)
		{
			$document = $this->find($doc_id->nodeValue);
			if (!empty($document))
			{
				$this->_em->remove($document);
				$deleted++;
				$this->_em->flush(); // commit each delete
			}
	
		}
		// setup return xml
		$response_xml = new \DOMDocument("1.0", "UTF-8");
		$root = $response_xml->appendChild($response_xml->createElement('Results'));
		if ($deleted !== 0)
		{
			$child = $response_xml->createElement('Result', 'OK');
			$attrib = $response_xml->createAttribute('ID');
			$attrib->value = 'Status';
			$child->appendChild($attrib);
			$root->appendChild($child);
	
			$child = $response_xml->createElement('Result', $deleted);
			$attrib = $response_xml->createAttribute('ID');
			$attrib->value = 'Ret1';
			$child->appendChild($attrib);
			$root->appendChild($child);
		}
		else {
			$child = $response_xml->createElement('Result', 'FAILED');
			$attrib = $response_xml->createAttribute('ID');
			$attrib->value = 'Status';
			$child->appendChild($attrib);
			$root->appendChild($child);
	
			$child = $response_xml->createElement('Result', 'Could not delete one or more of the selected documents.');
			$attrib = $response_xml->createAttribute('ID');
			$attrib->value = 'ErrMsg';
			$child->appendChild($attrib);
			$root->appendChild($child);
		}
		return $response_xml->saveXML();
	}
}